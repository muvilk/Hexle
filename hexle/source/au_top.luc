module au_top (
    input clk,              // 100MHz clock
    input rst_n,            // reset button (active low)
    output led [8],         // 8 user controllable LEDs
    input usb_rx,           // USB->Serial input
    output usb_tx,          // USB->Serial output
    output io_led [3][8],   // LEDs on IO Shield
    output io_seg [8],      // 7-segment LEDs on IO Shield (ANODE)
    output io_sel [4],      // Digit select on IO Shield
    input io_button [5],    // 5 buttons on IO Shield
    input io_dip [3][8],     // DIP switches on IO Shield
    
    input keypad[8].
    input green,
    input red,
    input highcontrast
    
  ) {
  
  sig rst;                  // reset signal
  alu alu;
  
  .clk(clk) {
    // The reset conditioner is used to synchronize the reset signal to the FPGA
    // clock. This ensures the entire FPGA comes out of reset at the same time.
    reset_conditioner reset_cond;
    button_conditioner button_conditioner[5];
    edge_detector edge_detector_manual[5](#RISE(1), #FALL(0));
    edge_detector edge_detector_auto(#RISE(1), #FALL(0));
    
    .rst(rst) {
      dff a[16];
      dff b[16];
      dff alufn[6];
      dff out[16];
      dff ans[16];
      fsm alu_runner = {A, B, OUT};
      multi_seven_seg seg (#DIGITS(2));
      multi_dec_ctr dec_ctr (#DIGITS(2));
      
    }
  }
  
  counter slowclock(#SIZE(1),#DIV(26), .clk(clk), .rst(edge_detector_manual.out[0]));
  autotester autotester(.clk(slowclock.value), .rst(rst));
  
  always {
  
    reset_cond.in = ~rst_n; // input raw inverted reset signal
    rst = reset_cond.out;   // conditioned reset
 
    usb_tx = usb_rx;         // connect tx output
 
    led = 8h00;             // turn LEDs off
    
    io_led = 3x{{8h00}};
    io_seg = 8b0; // connect segments to the driver
    io_sel = 4b0000; // turn on rightmost digit, and leftmost digit
    
    edge_detector_auto.in = slowclock.value;
    dec_ctr.inc = edge_detector_auto.out;
    seg.values = dec_ctr.digits;
     
    io_seg = 8hff; // connect segments to the driver
    io_sel = 4hf; // connect digit select to the driver
    
    button_conditioner.in = io_button[4:0];
    edge_detector_manual.in = button_conditioner.out;
  
    case (io_dip[2][7]) {
      b0: // manual functionality
        case (alu_runner.q){ // buttons to switch between setting A and B, states indicated through io_dip[2][7:5]
          alu_runner.A:
            a.d = c{io_dip[1], io_dip[0]};
            io_led[1] = a.q[15:8];
            io_led[0] = a.q[7:0];
            io_led[2][7:5] = b100;
            if (edge_detector_manual.out[1]){
              alu_runner.d = alu_runner.B;
            }
            
          alu_runner.B:
            b.d = c{io_dip[1], io_dip[0]};
            io_led[1] = b.q[15:8];
            io_led[0] = b.q[7:0];
            io_led[2][7:5] = b110; 
            if (edge_detector_manual.out[1]){
              
              alu_runner.d = alu_runner.OUT;
            }
     
          alu_runner.OUT:
            io_led[1] = alu.out[15:8];
            io_led[0] = alu.out[7:0];
            io_led[2][7:5] = b111;
            if(edge_detector_manual.out[1]){
              alu_runner.d = alu_runner.A;
            }
        } 
        alufn.d = io_dip[2][5:0];
        out.d = alu.out;
        
      b1: // autotesting mode
        a.d = autotester.alu_a;
        b.d = autotester.alu_b;
        alufn.d = autotester.alu_alufn;
        ans.d = autotester.alu_output;
        io_led[1] = alu.out[15:8];
        io_led[0] = alu.out[7:0];
        io_seg = ~seg.seg; // counter synced with slowclock is connected to 7-seg output to track state changes
        io_sel = ~seg.sel;
        
        
        case (io_dip[2][6]) { // LSB inverter
          b0: out.d = alu.out; // normal output
          b1: out.d = (alu.out[0] == 0) ? c{alu.out[15:1], 1} : c{alu.out[15:1], 0}; // LSB switched
        }
     
        // autochecker, checks alu's (modified) output against the correct answer from autotester_rom
        io_led[2][7]  = ((out.q == ans.q) == 1) ? 1 : 0;
        
    }
    
    case (alufn.q[5:1]) { // only displaying z v and n for ADD and SUB, hides it otherwise
      b00000:
        io_led[2][2] = alu.z;
        io_led[2][1] = alu.v;
        io_led[2][0] = alu.n;
    }

    alu.a = a.q;
    alu.b = b.q;
    alu.alufn_signal = alufn.q;
     
  }
}