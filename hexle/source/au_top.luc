module au_top (
    input clk,              // 100MHz clock
    input rst_n,            // reset button (active low)
    output led [8],         // 8 user controllable LEDs
    input usb_rx,           // USB->Serial input
    output usb_tx,          // USB->Serial output
    output io_led [3][8],   // LEDs on IO Shield
    output io_seg [8],      // 7-segment LEDs on IO Shield (ANODE)
    output io_sel [4],      // Digit select on IO Shield
    input io_button [5],    // 5 buttons on IO Shield
    input io_dip [3][8],     // DIP switches on IO Shield
    
    input key_sig[4],
    input green,
    input red,
    input high_contrast,
    
    output key_vdd[4],
    output digit[7],
    output rgb_red[4],
    output rgb_green[4],
    output rgb_blue[4]
    
  ) {
  
  sig rst;                  // reset signal
  sig keyclock[2];
  seven_seg_processor proc;
  
  
  .clk(clk) { // input > button conditioner > edge detector > dff
    // The reset conditioner is used to synchronize the reset signal to the FPGA
    // clock. This ensures the entire FPGA comes out of reset at the same time.
    reset_conditioner reset_cond;
    edge_detector slowclock_edge(#RISE(1), #FALL(0));
    
    button_conditioner green_button_conditioner;
    edge_detector green_button_edge(#RISE(1), #FALL(0));
    dff green_button;
    
    button_conditioner red_button_conditioner;
    edge_detector red_button_edge(#RISE(1), #FALL(0));
    dff red_button;
    
    button_conditioner hc_button_conditioner;
    edge_detector hc_button_edge(#RISE(1), #FALL(0));
    dff hc_button;
    
    button_conditioner keypad_button_conditioner[4];
    edge_detector keypad_button_edge[4](#RISE(1), #FALL(0));
    dff keypad_button[4];
    
    .rst(rst) {
      hexle_cpu hexle_cpu;
      counter frequency_divider(#SIZE(16));
      multi_seven_seg seg (#DIGITS(4));
      
    }
  }
    
  always {
  
    reset_cond.in = ~rst_n; // input raw inverted reset signal
    rst = reset_cond.out;   // conditioned reset
 
    usb_tx = usb_rx;         // connect tx output
 
    led = 8h00;             // turn LEDs off
    
    io_led = 3x{{8h00}};
    io_seg = 8b0; // connect segments to the driver
    io_sel = 4b1111; // turn off all digits
      
    //
    
    proc.cur_state = hexle_cpu.cur_state;
    seg.values = proc.values;
    
    io_seg = ~seg.seg; // counter synced with slowclock is connected to 7-seg output to track state changes
    io_sel = ~seg.sel;

    rgb_red = b1111;
    rgb_green = b1111;
    rgb_blue = b1111;
    key_vdd = b0000;
    
    red_button_conditioner.in = red;
    red_button_edge.in = red_button_conditioner.out;
    red_button.d = red_button_edge.out;
    
    green_button_conditioner.in = green;
    green_button_edge.in = green_button_conditioner.out;
    green_button.d = green_button_edge.out;
    
    keypad_button_conditioner.in = key_sig;
    keypad_button_edge.in = keypad_button_conditioner.out;
    keypad_button.d = keypad_button_edge.out;
    
    hc_button_conditioner.in = high_contrast;
    hc_button_edge.in = hc_button_conditioner.out;
    hc_button.d = hc_button_edge.out;

    if (hexle_cpu.cur_seg) {
      digit = frequency_divider.value[13:7];
    }

    if (hexle_cpu.cur_rgb[2] == 0) {
      rgb_red = frequency_divider.value[6:3];
    }

    if (hexle_cpu.cur_rgb[1] == 0) {
      rgb_green = frequency_divider.value[6:3];
    }

    if (hexle_cpu.cur_rgb[0] == 0) {
      rgb_blue = frequency_divider.value[6:3];
    }

    slowclock_edge.in = frequency_divider.value[2];
    keyclock = frequency_divider.value[1:0];
    
    hexle_cpu.red = red_button.q;
    hexle_cpu.green = green_button.q;
    hexle_cpu.key_sig = keypad_button.q;
    hexle_cpu.high_contrast = hc_button.q;  
    hexle_cpu.slowclk = slowclock_edge.out;  
    
    hexle_cpu.seg_sig = frequency_divider.value[13:7];
    hexle_cpu.rgb_sig = frequency_divider.value[6:3];
    hexle_cpu.keyclk = frequency_divider.value[1:0];
  
    
    case (keyclock) {
      b00: key_vdd = b1000;
      b01: key_vdd = b0100;
      b10: key_vdd = b0010;
      b11: key_vdd = b0001;
    }
  }
}