module au_top (
    input clk,              // 100MHz clock
    input rst_n,            // reset button (active low)
    output led [8],         // 8 user controllable LEDs
    input usb_rx,           // USB->Serial input
    output usb_tx,          // USB->Serial output
    output io_led [3][8],   // LEDs on IO Shield
    output io_seg [8],      // 7-segment LEDs on IO Shield (ANODE)
    output io_sel [4],      // Digit select on IO Shield
    input io_button [5],    // 5 buttons on IO Shield
    input io_dip [3][8],     // DIP switches on IO Shield
    
    input key_sig[8],
    input green,
    input red,
    input high_contrast,
    
    output digit,
    output digitclock[7],
    output rgb,
    output rgbclock[6]
    
  ) {
  
  sig rst;                  // reset signal
  
  
  .clk(clk) {
    // The reset conditioner is used to synchronize the reset signal to the FPGA
    // clock. This ensures the entire FPGA comes out of reset at the same time.
    reset_conditioner reset_cond;
    button_conditioner green_conditioner;
    button_conditioner red_conditioner;
    button_conditioner hc_conditioner;
    button_conditioner keypad_conditioner[8];
    
    .rst(rst) {
      hexle_cpu hexle_cpu;
      counter frequency_divider(#SIZE(15));
      pn_gen rng;
      
    }
  }
    
  always {
  
    reset_cond.in = ~rst_n; // input raw inverted reset signal
    rst = reset_cond.out;   // conditioned reset
 
    usb_tx = usb_rx;         // connect tx output
 
    led = 8h00;             // turn LEDs off
    
    io_led = 3x{{8h00}};
    io_seg = 8b0; // connect segments to the driver
    io_sel = 4b1111; // turn off all digits
      
    //
    
    
    
    red_conditioner.in = red;
    green_conditioner.in = green;
    keypad_conditioner.in = key_sig;
    hc_conditioner.in = high_contrast;
    
    hexle_cpu.red = red_conditioner.out;
    hexle_cpu.green = green_conditioner.out;
    hexle_cpu.key_sig = keypad_conditioner.out;
    hexle_cpu.high_contrast = hc_conditioner.out;    
    
    hexle_cpu.seg_sig = frequency_divider.value[12:6];
    hexle_cpu.rgb_sig = frequency_divider.value[5:0];
    
    digitclock = frequency_divider.value[12:6];
    rgbclock = frequency_divider.value[5:0];
    
    digit = hexle_cpu.cur_seg;
    rgb = hexle_cpu.cur_rgb;
    
    rng.next = hexle_cpu.next;
    rng.seed = hexle_cpu.seed;
    hexle_cpu.ans = rng.num[15:0];
     
  }
}