module control_unit (
    input clk,
    input rst,    
    //input slowclk,
    input green,
    input red,
    input keypad[4],
    input ra_data[16],
    output we,
    output ra[4],
    output rb[4],
    output rc[4],
    output bsel[3],
    output wdsel,
    output alufn[6]
  )
  
  const CU_ROM = { // format: c{ we (1 bit) + ra (4 bits) + rb (4 bits) + rc (4 bits) + bsel (3 bits) + wdsel (1 bit) + alufn (6 bits)} IN THIS ORDER; total: 23 bits in length
    b10000000000010001000000, //Reset_A1
    b10000000000110001000000, //Reset_A1_RGB
    b10000000000100001000000, //Reset_A2
    b10000000001000001000000, //Reset_A2_RGB
    b10000000010000001000000, //Reset_Hint
    b10000000001110001000000, //Reset_Hint_RGB
    b10000000001100001000000, //Reset_Counter
    b10000000001010001000000, //Reset_Counter_RGB
    b00000000000000000000000, //Initialisation
    b11001000000000100000110, //Answer_Generation
    b10000000011100000101111, //Max_Digit
    b10000000011110000111111, //Min_Digit
    b11110111110000000000001, //Hint_Calculation_(-)
    b10111000101110010000000, //Hint_RGB
    b10000000011110010000101, //A1D1_(a)
    b11111110011110010000010, //A1D1_(b)
    b10001111100010000000000, //A1D1(c)_
    b10011000000111000000000, //A1D1_(d)
    b11111100011110010000010, //A1D2(b)
    b10011000000110110000000, //A1D2_(d)
    b11111010011110010000010, //A1D3_(b)
    b10011000000110100000000, //A1D3_(d)
    b11111000011110010000010, //A1D4_(b)
    b10011000100110010000000, //A1D4_(d)
    b10001111100010000000001, //A1D1_(e)
    b10011000000111000000001, //A1D1_(f)
    b10011000000110110000001, //A1D2(f)
    b10011000000110100000001, //A1D3_(f)
    b10011000100110010000001, //A1D4_(f)
    b10001000011110000101111, //A1_Max
    b10001000011100000111111, //A1_Min
    b11111111011100000000001, //A1_Hint
    b11110100011100000000011, //A1_COMPEQ
    b11110000000000000000000, //A1_Check
    b10000000110010000000101, //Seed
    b10110000101100010000000, //Counter
    b10101000101010010000000, //Counter_RGB
    b10000000111110000000111, //A1_Check_Green
    b11111001011110010000010, //A1_Shift_Green
    b11111001100110000000000, //A1_Merge_Green
    b10000000111110000010111, //A1_Check_Yellow
    b11111000111110010000010, //A1_Shift_Yellow
    b10011111100110000000000, //A1_Merge_Yellow
    b10010111100100000000000, //A2D1(c)_
    b10100000001001000000000, //A2D1_(d)
    b10100000001000110000000, //A2D2_(d)
    b10100000001000100000000, //A2D3_(d)
    b10100000101000010000000, //A2D4_(d)
    b10010111100100000000001, //A2D1_(e)
    b10100000001001000000001, //A2D1_(f)
    b10100000001000110000001, //A2D2(f)
    b10100000001000100000001, //A2D3_(f)
    b10100000101000010000001, //A2D4_(f)
    b10010000011110000101111, //A2_Max
    b10010000011100000111111, //A1_Min
    b00011000000000000000000, //Branch_D1
    b10001001111100010100111, //Extract_A1D1
    b10010001111110010100111, //Extract_A2D1
    b11110111111100000000011, //D1G_CMPEQ
    b10001111011110000110111, //Count_A1D1_in_A1
    b10010111011100000110111, //Count_A1D1_in_A2
    b11111111011100000000100, //D1Y_CMPLE
    b01110000000000000000000, //D1_Return_Branch
    b10001001011100010100111, //Extract_A1D2
    b10010001011110010100111, //Extract_A2D2
    b10001000111100010100111, //Extract_A1D3
    b10010000111110010100111, //Extract_A2D3
    b10001000011100010100111, //Extract_A1D4
    b10010000011110010100111, //Extract_A2D4
    b10000001011110000000111, //A2_Check_Green
    b11111010001000000000000, //A2_Merge_Green
    b10000001011110000010111, //A2_Check_Yellow
    b10100111101000000000000, //A2_Merge_Yellow
    b10000001000010001000101, //Migrate_A2_(Digit)
    b10000010000110001000101 //Migrate_A2_(Digit)
  };
  
  .clk(clk) {
    .rst(rst) {
      fsm state = {Reset_A1, Reset_A1_RGB, Reset_A2, Reset_A2_RGB, Reset_Hint, Reset_Hint_RGB, Reset_Counter, Reset_Counter_RGB, Initialisation, Answer_Generation, Max_Digit, Min_Digit, Hint_Calculation_(-), Hint_RGB, End, A1D0, A1D1_(a), A1D1_(b), A1D1(c)_, A1D1_(d), A1D1, A1D2_(a), A1D2(b), A1D2(c)_, A1D2_(d), A1D2, A1D3_(a), A1D3_(b), A1D3_(c), A1D3_(d), A1D3, A1D4_(a), A1D4_(b), A1D4_(c), A1D4_(d), A1D4, A1D1_(e), A1D1_(f), A1D2_(e), A1D2(f), A1D3_(e), A1D3_(f), A1D4_(e), A1D4_(f), A1_Max, A1_Min, A1_Hint, A1_COMPEQ, A1_Check, Seed, Counter, Counter_RGB, A1_Check_Green, A1_Shift_Green, A1_Merge_Green, A1_Check_Yellow, A1_Shift_Yellow, A1_Merge_Yellow, A2D0, A2D1_(a), A2D1_(b), A2D1(c)_, A2D1_(d), A2D1, A2D2_(a), A2D2(b), A2D2(c)_, A2D2_(d), A2D2, A2D3_(a), A2D3_(b), A2D3_(c), A2D3_(d), A2D3, A2D4_(a), A2D4_(b), A2D4_(c), A2D4_(d), A2D4, A2D1_(e), A2D1_(f), A2D2_(e), A2D2(f), A2D3_(e), A2D3_(f), A2D4_(e), A2D4_(f), A2_Max, A1_Min, A2_Hint, A2_COMPEQ, A2_Check, Counter, Counter_RGB, Branch_D1, Extract_A1D1, Branch_D1_G/Y, Extract_A2D1, D1G_CMPEQ, Count_A1D1_in_A1, Count_A1D1_in_A2, D1Y_CMPLE, D1_Return_Branch, Branch_D2, Extract_A1D2, Branch_D2_G/Y, Extract_A2D2, D2G_CMPEQ, Count_A1D2_in_A1, Count_A1D2_in_A2, D2Y_CMPLE, D2_Return_Branch, Branch_D3, Extract_A1D3, Branch_D3_G/Y, Extract_A2D3, D3G_CMPEQ, Count_A1D3_in_A1, Count_A1D3_in_A2, D3Y_CMPLE, D3_Return_Branch, Branch_D4, Extract_A1D4, Branch_D4_G/Y, Extract_A2D4, D4G_CMPEQ, Count_A1D4_in_A1, Count_A1D4_in_A2, D4Y_CMPLE, D4_Return_Branch, A2_Check_Green, A2_Shift_Green, A2_Merge_Green, A2_Check_Yellow, A2_Shift_Yellow, A2_Merge_Yellow, Migrate_A2_(Digit), Migrate_A2_(Digit), Reset_A2_(Digit), Reset_A2_(RGB)}; // we need to add everything here
      dff address[7]; // adjust bits when we finalise our number of unique control signal combinations ALSO not sure if we need to use dffs or can just initialise a varialbe
    }
  }
 
  always {
    
    we = CU_ROM[address.q][22];
    ra = CU_ROM[address.q][21:18];
    rb = CU_ROM[address.q][17:14];
    rc = CU_ROM[address.q][13:10];
    bsel = CU_ROM[address.q][9:7];
    wdsel = CU_ROM[address.q][6];
    alufn = CU_ROM[address.q][5:0];
    
    case (state.q) {
      state.INITIALIZATION:
        address.d = b00;
        state.d = state.ANSWER_GENERATION;
        
      state.ANSWER_GENERATION:
        address.d = b01;
        state.d = state.MAX_DIGIT;
        
      state.MAX_DIGIT:
        address.d = b10;
        state.d = state.MIN_DIGIT; // min digit not defined yet
        
      state.EXAMPLE:
        address.d = 6b0; // address of CURRENT state, will be the same regardless of button pressed
        case(green || red) { // if enter/delete is pressed
          b1:
            state.d = state.INITIALIZATION; //go to initialization NO NEED to define b0 case, that would lead to automatic switching which we don't want
            state.d = state.EXAMPLE; // in the event that it is meant to loop, actually code wise we don't need to put the case for a loop in i think cause naturally if not defined nothing will happen
         }
        
      state.EXAMPLE2:
        address.d = 6b0;
        ra = keypad; // i believe this will overwrite the default value, so for instructions taking in keypad for an input can just put 0000 as a placeholder or sth
      
        
      state.EXAMPLE3: // branching example - reads ra directly from REGFILE
        case(ra_data) { // for branching states, no control signals 
          h4444:
            state.d = state.EXAMPLE;
          default:
            state.d = state.EXAMPLE2;               
    }
  }
}
